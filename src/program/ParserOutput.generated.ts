import type {Cl, Cm, Cnst, Dt, Nu, Op, Sc, Tc, Tp, Vr} from "./CustomLexer";
import {Set as ISet} from 'immutable';
import type {Instruction} from "./GrammarParser";
export type Start = Blo;
export type Ass = {type: 'ass', value: [Rec_, Exp];};
export type Ret = {type: 'ret', value: [Exp];};
export type Brk = {type: 'brk', value: [];};
export type Cnt = {type: 'cnt', value: [];};
export type Bls = Ife | Dow | Wdo | For | Doo;
export type Sta = Ass | Ret | Brk | Cnt | Exp;
export type Rec = {type: 'rec', value: [Exp, Dt, Vr];};
export type Rec_ = Var | Nu | Rec;
export type Blo = Sta[];
export type Ife = {type: 'ife', value: [Ifb, Ifn, Blo] | [Ifb, Ifn];};
export type Ifn = Ifb[];
export type Ifb = {type: 'ifb', value: [Exp, Blo];};
export type Dow = {type: 'dow', value: [Blo, Exp];};
export type Wdo = {type: 'wdo', value: [Exp, Blo];};
export type For = {type: 'for', value: [Var, Exp, Blo];};
export type Doo = {type: 'doo', value: [Blo];};
export type Exp = Fnd | Exc | Exl | Exm | Arr | Exo | Dot | Vr | Cnst | Nu | Bls;
export type Fnd = {type: 'fnd', value: [Vrl, Typ, Exp] | [Vrl, Exp] | [Vrl, Tc];};
export type Exc = {type: 'exc', value: [Exp, Sc];};
export type Exl = {type: 'exl', value: [Exp, Cl, Exp];};
export type Arr = {type: 'arr', value: [Arr, Cm, Exp] | [Exp] | [];};
export type Exm = {type: 'exm', value: [Exm, Cm, Exp] | [Cm, Exp];};
export type Exo = {type: 'exo', value: [Exp, Op, Exp];};
export type Dot = {type: 'dot', value: [Exp, Dt, Vr];};
export type Typ = Ftp | Ttp | Atp | Tc | Tp | Mtp;
export type Mtp = {type: 'mtp', value: [Typ];};
export type Ttp = {type: 'ttp', value: [Cm, Typ] | [Ttp, Cm, Typ];};
export type Atp = {type: 'atp', value: [Typ];};
export type Ftp = {type: 'ftp', value: [Typ] | [Tps, Typ];};
export type Tps = (Typ | Cl)[];
export type Var = {type: 'var', value: [Vr] | [Vr, Typ];};
export type Vrl = Var[];
export const renames = {ass: 'ass', ret: 'ret', brk: 'brk', cnt: 'cnt', rec: 'rec', ife: 'ife', ifb: 'ifb', dow: 'dow', wdo: 'wdo', for: 'for', doo: 'doo', fnd: 'fnd', exc2: 'exc', exc1: 'exc', exc0: 'exc', exl2: 'exl', exl1: 'exl', exl0: 'exl', ars2: 'arr', ars1: 'arr', ars0: 'arr', arre: 'arr', exm2: 'exm', exm1: 'exm', exm0: 'exm', exo2: 'exo', exo1: 'exo', exo0: 'exo', dot: 'dot', mtp: 'mtp', ttp: 'ttp', atp: 'atp', ftp: 'ftp', var: 'var'} as const;
export type RenamedParserName = keyof typeof renames;
export type FinalParserName = typeof renames[RenamedParserName];
export const RenamedParserNames = ISet<string>(Object.keys(renames));
export const FinalParserNames = ISet<string>(Object.values(renames));
const FilteredParserNames_ = ['doc', 'mnl', 'wnl', 'bls', 'sta', 'sep', 'eob', 'blo', 'ifl', 'ifn', 'exp', 'eod', 'exa2', 'emo2', 'emo1', 'emo0', 'exa1', 'exa0', 'vcf', 'mws', 'ws', 'sc2', 'sc1', 'sc0', 'op2', 'op1', 'op0', 'cm2', 'cm1', 'cm0', 'cl2', 'cl1', 'cl0', 'typ', 'tps', 'vrl'] as const;
export type FilteredParserName = typeof FilteredParserNames_[number];
export const FilteredParserNames = ISet<string>(FilteredParserNames_);
export type DirtyParserName = RenamedParserName | FilteredParserName;
export const instructions: {[key in DirtyParserName]: Instruction} = {doc: 'fu', mnl: 'd', wnl: 'd', ass: 'fl', ret: 'fl', brk: 'fl', cnt: 'fl', bls: 'fu', sta: 'fu', sep: 'd', rec: 'fm', eob: 'fu', blo: 'ff', ife: 'fl', ifl: 'fu', ifn: 'ff', ifb: 'fl', dow: 'fl', wdo: 'fl', for: 'fl', doo: 'fl', exp: 'fu', eod: 'fu', fnd: 'fl', exa2: 'fu', exc2: 'fm', exc1: 'fm', exc0: 'fm', exl2: 'fm', exl1: 'fm', exl0: 'fm', emo2: 'fu', emo1: 'fu', emo0: 'fu', ars2: 'fl', ars1: 'fl', ars0: 'fl', arre: 'fl', exm2: 'fm', exm1: 'fm', exm0: 'fm', exo2: 'fm', exo1: 'fm', exo0: 'fm', exa1: 'fu', exa0: 'fu', dot: 'fm', vcf: 'fu', mws: 'd', ws: 'd', sc2: 'fu', sc1: 'fu', sc0: 'fu', op2: 'fu', op1: 'fu', op0: 'fu', cm2: 'fu', cm1: 'fu', cm0: 'fu', cl2: 'fu', cl1: 'fu', cl0: 'fu', typ: 'fu', mtp: 'fl', ttp: 'fl', atp: 'fl', ftp: 'fl', tps: 'ff', var: 'fl', vrl: 'ff'};

