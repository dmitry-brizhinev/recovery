import type {Cl, Cm, Cnst, Dt, Nu, Op, Sc, Tc, Tp, Vr} from "./CustomLexer";
import {Set as ISet} from 'immutable';
import type {Instruction} from "./GrammarParser";
export type Start = Blo;
export type Ass = {type: 'ass', value: [Rec_, Exp];};
export type Ret = {type: 'ret', value: [Exp];};
export type Brk = {type: 'brk', value: [];};
export type Cnt = {type: 'cnt', value: [];};
export type Bls = Ife | Dow | Wdo | For | Doo;
export type Sta = Ass | Ret | Brk | Cnt | Exp;
export type Rec = {type: 'rec', value: [Exp, Dt, Vr];};
export type Rec_ = Var | Nu | Rec;
export type Blo = Sta[];
export type Ife = {type: 'ife', value: [Ifb, Ifn, Blo] | [Ifb, Ifn];};
export type Ifn = Ifb[];
export type Ifb = {type: 'ifb', value: [Exp, Blo];};
export type Dow = {type: 'dow', value: [Blo, Exp];};
export type Wdo = {type: 'wdo', value: [Exp, Blo];};
export type For = {type: 'for', value: [Var, Exp, Blo];};
export type Doo = {type: 'doo', value: [Blo];};
export type Exp = Fnd | Exc | Exl | Exm | Arr | Exo | Dot | Vr | Cnst | Nu | Bls;
export type Fnd = {type: 'fnd', value: [Vrl, Typ, Exp] | [Vrl, Exp] | [Vrl, Tc];};
export type Exc = {type: 'exc2' | 'exc1' | 'exc0', value: [Exp, Sc];};
export type Exl = {type: 'exl2' | 'exl1' | 'exl0', value: [Exp, Cl, Exp];};
export type Arr = {type: 'ars2' | 'ars1' | 'ars0' | 'arre', value: [Arr, Cm, Exp] | [Exp] | [];};
export type Exm = {type: 'exm2' | 'exm1' | 'exm0', value: [Exm, Cm, Exp] | [Cm, Exp];};
export type Exo = {type: 'exo2' | 'exo1' | 'exo0', value: [Exp, Op, Exp];};
export type Dot = {type: 'dot', value: [Exp, Dt, Vr];};
export type Typ = Ftp | Ttp | Atp | Tc | Tp | Mtp;
export type Mtp = {type: 'mtp', value: [Typ];};
export type Ttp = {type: 'ttp', value: [Cm, Typ] | [Ttp, Cm, Typ];};
export type Atp = {type: 'atp', value: [Typ];};
export type Ftp = {type: 'ftp', value: [Typ] | [Tps, Typ];};
export type Tps = (Typ | Cl)[];
export type Var = {type: 'var', value: [Vr] | [Vr, Typ];};
export type Vrl = Var[];
const ParserNames_ = ['ass', 'ret', 'brk', 'cnt', 'rec', 'ife', 'ifb', 'dow', 'wdo', 'for', 'doo', 'fnd', 'exc2', 'exc1', 'exc0', 'exl2', 'exl1', 'exl0', 'ars2', 'ars1', 'ars0', 'arre', 'exm2', 'exm1', 'exm0', 'exo2', 'exo1', 'exo0', 'dot', 'mtp', 'ttp', 'atp', 'ftp', 'var'] as const;
export type ParserName = typeof ParserNames_[number];
export const ParserNames = ISet<string>(ParserNames_);
const FilteredParserNames_ = ['doc', 'mnl', 'wnl', 'bls', 'sta', 'sep', 'eob', 'blo', 'ifl', 'ifn', 'exp', 'eod', 'exa2', 'emo2', 'emo1', 'emo0', 'exa1', 'exa0', 'vcf', 'mws', 'ws', 'sc2', 'sc1', 'sc0', 'op2', 'op1', 'op0', 'cm2', 'cm1', 'cm0', 'cl2', 'cl1', 'cl0', 'typ', 'tps', 'vrl'] as const;
export type FilteredParserName = typeof FilteredParserNames_[number];
export const FilteredParserNames = ISet<string>(FilteredParserNames_);
export type DirtyParserName = ParserName | FilteredParserName;
export const instructions: {[key in DirtyParserName]: Instruction} = {doc: 'fu', mnl: 'd', wnl: 'd', ass: 'fl', ret: 'fl', brk: 'fl', cnt: 'fl', bls: 'fu', sta: 'fu', sep: 'd', rec: 'fm', eob: 'fu', blo: 'ff', ife: 'fl', ifl: 'fu', ifn: 'ff', ifb: 'fl', dow: 'fl', wdo: 'fl', for: 'fl', doo: 'fl', exp: 'fu', eod: 'fu', fnd: 'fl', exa2: 'fu', exc2: 'fm', exc1: 'fm', exc0: 'fm', exl2: 'fm', exl1: 'fm', exl0: 'fm', emo2: 'fu', emo1: 'fu', emo0: 'fu', ars2: 'fl', ars1: 'fl', ars0: 'fl', arre: 'fl', exm2: 'fm', exm1: 'fm', exm0: 'fm', exo2: 'fm', exo1: 'fm', exo0: 'fm', exa1: 'fu', exa0: 'fu', dot: 'fm', vcf: 'fu', mws: 'd', ws: 'd', sc2: 'fu', sc1: 'fu', sc0: 'fu', op2: 'fu', op1: 'fu', op0: 'fu', cm2: 'fu', cm1: 'fu', cm0: 'fu', cl2: 'fu', cl1: 'fu', cl0: 'fu', typ: 'fu', mtp: 'fl', ttp: 'fl', atp: 'fl', ftp: 'fl', tps: 'ff', var: 'fl', vrl: 'ff'};

